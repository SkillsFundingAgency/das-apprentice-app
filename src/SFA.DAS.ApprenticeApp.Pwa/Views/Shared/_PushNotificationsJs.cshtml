<script src="https://code.jquery.com/jquery-3.7.1.min.js" integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>
<script type="text/javascript">
    //step 3: register the service worker
    let registration = navigator.serviceWorker.register("../service-worker.js");
    let thisEndpoint = "";

    //step 4: get subscription if exists
    requestSubscription();

    async function requestSubscription() {
        if (document.referrer === '' || document.referrer.includes('account-details') || document.referrer.includes('Terms') || document.referrer.includes('Welcome')) {
            const worker = await navigator.serviceWorker.getRegistration();
            const existingSubscription = await worker.pushManager.getSubscription();

            if (existingSubscription) {
                thisEndpoint = existingSubscription.endpoint;
                sendSubscriptionToServer(existingSubscription, true);
            }
        }
    }

    // FIXED: Improved notification permission handling with timeout
    async function requestNotificationPermission() {

        // Remove the notifications dialogue on continue click
        const notificationDiv = document.querySelector('.enable-notifications');
        if (notificationDiv) {
            notificationDiv.remove();
            console.log('Notification dialogue removed successfully');
        }

        try {
            // Check current permission state first
            if (Notification.permission === 'granted') {
                displayNotificationButtons();
                return;
            }

            // Add timeout to prevent hanging
            const permissionPromise = Notification.requestPermission();
            const timeoutPromise = new Promise((resolve) => {
                setTimeout(() => resolve('timeout'), 5000); // 5-second timeout
            });

            const result = await Promise.race([permissionPromise, timeoutPromise]);

            if (result === 'timeout') {
                console.warn('Permission request timed out');

                if (notificationDiv) {
                    notificationDiv.remove();
                    console.log('Notification dialogue removed successfully');
                }                
                
            } else {
                console.log('Notification permission:', result);

                if (notificationDiv) {
                    notificationDiv.remove();
                    console.log('Notification dialogue removed successfully');
                }
                
            }
        } catch (error) {

            if (notificationDiv) {
                notificationDiv.remove();
                console.log('Notification dialogue removed successfully');
            }
            
            console.error('Error requesting notification permission:', error);
        } finally {
            // Always update UI regardless of outcome
            displayNotificationButtons();
        }
    }

    function registerPush(registration) {
        const applicationServerPublicKey = window.pushNotificationKey;
        const applicationServerKey = urlB64ToUint8Array(applicationServerPublicKey);

        return registration.pushManager
            .subscribe({
                userVisibleOnly: true,
                applicationServerKey: applicationServerKey,
            })
            .then((subscription) => {
                thisEndpoint = subscription.endpoint;
                return sendSubscriptionToServer(subscription, false);
            })
            .catch((error) => {
                console.error("Failed to subscribe the user: ", error);
            });
    }

    function sendSubscriptionToServer(subscription, isSubscribed) {
        // FIX: Handle null keys safely
        const p256dhKey = subscription.getKey("p256dh");
        const authKey = subscription.getKey("auth");

        const requestData = new SubscriptionRequest(
            subscription.endpoint,
            p256dhKey ? arrayBufferToBase64(p256dhKey) : "",
            authKey ? arrayBufferToBase64(authKey) : "",
            isSubscribed
        );

        return fetch("/Profile/AddSubscription", {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            },
            body: JSON.stringify(requestData),
        })
            .then((response) => {
                if (!response.ok) {
                    throw new Error("Error from server while adding subscription.");
                }
                displayNotificationButtons();
            })
            .catch((error) => {
                console.error("Error sending subscription to server:", error);
            });
    }

    async function unsubscribe() {
        const requestData = new RemoveSubscriptionRequest(
            thisEndpoint
        );
        return fetch("/Profile/RemoveSubscription", {
            method: "DELETE",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(requestData),
        })
            .then((response) => {
                if (!response.ok) {
                    throw new Error("Error from server while removing subscription.");
                }
                displayNotificationButtons();
            })
            .catch((error) => {
                console.error("Error sending subscription to server:", error);
            });
    }

    function urlB64ToUint8Array(base64String) {
        // FIX: Add null/undefined check
        if (!base64String) {
            console.error("urlB64ToUint8Array: base64String is null or undefined");
            return new Uint8Array();
        }

        const padding = "=".repeat((4 - (base64String.length % 4)) % 4);
        const base64 = (base64String + padding).replace(/-/g, "+").replace(/_/g, "/");

        const rawData = window.atob(base64);
        const outputArray = new Uint8Array(rawData.length);

        for (let i = 0; i < rawData.length; ++i) {
            outputArray[i] = rawData.charCodeAt(i);
        }
        return outputArray;
    }

    function arrayBufferToBase64(buffer) {
        // FIX: Handle null/undefined buffer
        if (!buffer) {
            console.error("arrayBufferToBase64: buffer is null or undefined");
            return "";
        }

        let binary = "";
        let bytes = new Uint8Array(buffer);
        let len = bytes.byteLength;
        for (let i = 0; i < len; i++) {
            binary += String.fromCharCode(bytes[i]);
        }
        return window.btoa(binary);
    }

    class SubscriptionRequest {
        constructor(endpoint, publicKey, authenticationsecret, issubscribed) {
            this.endpoint = endpoint;
            this.publicKey = publicKey;
            this.authenticationsecret = authenticationsecret;
            this.issubscribed = issubscribed;
        }
    }

    class RemoveSubscriptionRequest {
        constructor(endpoint) {
            this.endpoint = endpoint;
        }
    }

    // FIXED: Enhanced permission change handler with safe checks
    async function handlePermissionChange(permission) {
        try {
            if (permission === "granted") {
                console.log("Notifications enabled by user");
                let worker = await navigator.serviceWorker.getRegistration();

                // Added timeout for worker retrieval
                if (!worker) {
                    const workerTimeout = setTimeout(() => {
                        console.warn("Service worker registration timed out");
                        displayNotificationButtons();
                    }, 3000);

                    worker = await navigator.serviceWorker.getRegistration();
                    clearTimeout(workerTimeout);
                }

                if (worker) {
                    await registerPush(worker);
                } else {
                    console.warn("Service worker not available");
                }
            } else if (permission === "denied") {
                console.log("Notifications disabled by user");
                await unsubscribe();
            }
        } catch (error) {
            console.error("Error handling permission change:", error);
        } finally {
            // FIX: Add null check before display function
            if (typeof displayNotificationButtons === 'function') {
                displayNotificationButtons();
            }
        }
    }

    // FIXED: Permission listener with fallback and safe checks
    document.addEventListener("DOMContentLoaded", (event) => {
        // FIX: Ensure Notification API is available
        if (!("Notification" in window)) {
            console.warn("Notifications not supported");
            return;
        }

        // Use modern Permissions API if available
        if (navigator.permissions && navigator.permissions.query) {
            navigator.permissions.query({ name: "notifications" })
                .then((permissionStatus) => {
                    if (permissionStatus) {
                        permissionStatus.onchange = () => {
                            handlePermissionChange(permissionStatus.state);
                        };
                    }
                })
                .catch(error => {
                    console.warn('Permissions API error:', error);
                    // Fallback to notification permission
                    handlePermissionChange(Notification.permission);
                });
        } else {
            // Fallback for browsers without Permissions API
            handlePermissionChange(Notification.permission);
        }

        // Added permission state tracking for Android workaround
        let permissionState = Notification.permission;
        function trackPermissionChanges() {
            if (Notification.permission !== permissionState) {
                permissionState = Notification.permission;
                handlePermissionChange(permissionState);
            }
        }
        setInterval(trackPermissionChanges, 3000);
    });

    function testNotification() {
        const body = "You have successfully subscribed to notifications!"
        const icon = 'govuk-icon-512.png'
        const options = {
            body: body,
            icon: icon,
        };
        new Notification("Test Notification", options);
    }

    // Added manual refresh function for Android workaround
    function refreshNotificationState() {
        // FIX: Add null check before display function
        if (typeof displayNotificationButtons === 'function') {
            displayNotificationButtons();
        }
    }
</script>